#!python

"""Phylogenetic inference using deep mutational scanning data.

Written by Jesse Bloom."""


import sys
import os
import re
import logging
import random
import time
import math
import multiprocessing
import scipy
import Bio.Phylo
import phydmslib
import phydmslib.constants
import phydmslib.file_io
import phydmslib.parsearguments
import phydmslib.models
import phydmslib.treelikelihood


def main():
    """Main body of script."""

    # Parse command line arguments
    parser = phydmslib.parsearguments.PhyDMSParser()
    args = vars(parser.parse_args())
    prog = parser.prog

    # create output directory if needed
    outdir = os.path.dirname(args['outprefix'])
    if outdir:
        if not os.path.isdir(outdir):
            if os.path.isfile(outdir):
                os.remove(outdir)
            os.mkdir(outdir)

    # output files, remove if they already exist
    modelparamsfile = '%s_modelparams.txt' % args['outprefix']
    loglikelihoodfile = '%s_loglikelihood.txt' % args['outprefix']
    treefile = "%s_tree.newick" % args['outprefix']
    omegafile = '%s_omegabysite.txt' % args['outprefix']
    logfile = "%s.log" % args['outprefix']
    to_remove = [modelparamsfile, loglikelihoodfile, treefile, omegafile, logfile]
    for f in to_remove:
        if os.path.isfile(f):
            os.remove(f)

    # Set up to log everything to logfile.
    logging.shutdown()
    logging.captureWarnings(True)
    versionstring = phydmslib.file_io.Versions() 
    logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', 
            level=logging.INFO)
    logger = logging.getLogger(prog)
    logfile_handler = logging.FileHandler(logfile)
    logger.addHandler(logfile_handler)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    logfile_handler.setFormatter(formatter)

    # begin execution
    try:
        # print some basic information
        logger.info('Beginning execution of {0} in directory {1}\n'.format(
                prog, os.getcwd()))
        logger.info('Progress is being logged to {0}\n'.format(logfile))
        logger.info("{0}\n".format(versionstring))
        logger.info('Parsed the following arguments:\n{0}\n'.format(
                '\n'.join(['\t{0} = {1}'.format(*tup) for tup in args.items()])))
        logger.info('Random number seed: {0}\n'.format(args['seed']))
        random.seed(args['seed'])

        # read alignment
        logger.info('Reading alignment from {0}'.format(args['alignment']))
        alignment = phydmslib.file_io.ReadCodonAlignment(args['alignment'], 
                checknewickvalid=True)
        logger.info(('Read {0} aligned sequences from {1}, each consisting '
                'of {2} codons.\n').format(len(alignment), args['alignment'], 
                len(alignment[0][1]) // 3))
        seqnames = set([head for (head, seq) in alignment])

        # process the substitution model
        yngkp_match = re.compile('^YNGKP_M(?P<modelvariant>\d+)$')
        if isinstance(args['model'], str) and yngkp_match.search(args['model']):
            for argname in ['randprefs', 'avgprefs', 'divpressure']:
                assert not args[argname], "'--%s' incompatible with YNKGP".format(
                            argname)
            modelvariant = yngkp_match.search(args['model']).group('modelvariant')
            logger.info(('The codon substitution model with be the M{0} version '
                    'of YNGKP (Yang, Nielsen, Goldman, and Pederson. Genetics. '
                    '155:431-449).').format(modelvariant))
            raise RuntimeError('YNGKP models not yet implemented')
        elif (isinstance(args['model'], tuple) and len(args['model']) == 2 and 
                args['model'][0] == 'ExpCM'):
            prefsfile = args['model'][1]
            logger.info(('The model will be an ExpCM informed by site-specific '
                    'amino-acid preferences in {0}').format(prefsfile))
            for (argname, desc) in [('avgprefs', 'averaged'), 
                    ('randprefs', 'randomized')]:
                if args[argname]:
                    logger.info('Preferences will be {0} across sites.'.format(desc))
            prefs = phydmslib.file_io.readPrefs(prefsfile, minpref=args['minpref'], 
                    avgprefs=args['avgprefs'], randprefs=args['randprefs'],
                    seed=args['seed'])
            sites = sorted(prefs.keys())
            prefslist = [prefs[r] for r in sites] # convert prefs from dict to list
            assert len(prefs) == len(alignment[0][1]) // 3, ("The number of "
                    "preferences in {0} does not match the number of codon "
                    "sites in the alignment").format(prefsfile)
            logger.info(('Successfully read site-specific amino-acid preferences '
                    'for all {0} sites.\n').format(len(prefs)))
            freeparams = ['kappa', 'omega', 'beta']
            if args['brlen'] == 'scale':
                logger.info("Scaling branch lengths by adding 'mu' parameter "
                        "to model.\n")
                freeparams.append('mu')
            if args['fitphi']:
                assert not args['divpressure'], (
                        "Can't use --divpressure and --fitphi")
                freeparams.append('eta')
                logger.info('Nucleotide frequency parameters phi will '
                        'be optimized by maximum likelihood.\n')
                model = phydmslib.models.ExpCM(prefslist, freeparams=freeparams)
            else:
                g = scipy.ndarray(phydmslib.constants.N_NT, dtype='float')
                for (w, nt) in phydmslib.constants.INDEX_TO_NT.items():
                    g[w] = sum([seq.count(nt) for (head, seq) in alignment])
                assert len(alignment) * len(prefs) * 3 == (g.sum() + 
                        sum([seq.count('-') for (head, seq) in alignment])), (
                        "Alignment contains invalid nucleotide characters")
                g /= g.sum()
                logger.info('Nucleotide frequency parameters phi will be '
                        'set so stationary state matches alignment '
                        'nucleotide frequencies of {0}\n'.format(
                        ', '.join(['{0} = {1:.3f}'.format(nt, g[w]) for
                        (w, nt) in phydmslib.constants.INDEX_TO_NT.items()])))
                if not args['divpressure']:
                    model = phydmslib.models.ExpCM_empirical_phi(prefslist, g,
                        freeparams=freeparams)
                else:
                    for otherarg in ['omegabysite']:
                        if otherarg in args and args[otherarg]:
                            raise ValueError("Can't use --divpressure and "
                                    "--{0}".format(otherarg))
                    freeparams.append('omega2')
                    divpressure = phydmslib.file_io.readDivPressure(
                            args['divpressure'])
                    assert set(prefs.keys()) == set(divpressure.keys()), (
                            "The sites in {0} are different from {1}.".format(
                            args['divpressure'], prefsfile))
                    logger.info(('Read diversifying pressure from {0} '
                            'for all sites.').format(args['divpressure']))
                    divPressureSites = list(divpressure.keys())
                    divpressure = scipy.array([divpressure[x] for x in 
                            sorted(divPressureSites)])
                    model = phydmslib.models.ExpCM_empirical_phi_divpressure(
                            prefslist, g, divpressure, freeparams=freeparams)
        else:
            raise ValueError("Invalid model of %s" % args['model'])

        # read tree
        logger.info("Reading tree from %s" % args['tree'])
        tree = Bio.Phylo.read(args['tree'], 'newick')
        tipnames = set([clade.name for clade in tree.get_terminals()])
        assert len(tipnames) == tree.count_terminals(), "non-unique tip names?"
        assert tipnames == seqnames, ("Names in alignment do not match those in "
                "tree.\nSequences in alignment but NOT in tree:\n\t{0}\n"
                "Sequences in tree but NOT in alignment:\n\t{1}".format(
                '\n\t'.join(seqnames - tipnames), '\n\t'.join(tipnames - seqnames)))
        logger.info('Tree has {0} tips.'.format(len(tipnames)))
        tree.root_at_midpoint()
        assert tree.is_bifurcating(), "Tree is not bifurcating: cannot handle"
        nadjusted = 0
        for node in tree.get_terminals() + tree.get_nonterminals():
            if node.branch_length < args['minbrlen']:
                nadjusted += 1
                node.branch_length = args['minbrlen']
        logger.info('Adjusted {0} branch lengths up to minbrlen {1}\n'.format(
                nadjusted, args['minbrlen']))

        # set up tree likelihood
        logger.info('Initializing TreeLikelihood..')
        tl = phydmslib.treelikelihood.TreeLikelihood(tree, alignment, model)
        logger.info('TreeLikelihood initialized.')

        # maximize likelihood
        logger.info('Maximizing log likelihood (initial value {0:.2f})...'.format(
                tl.loglik))
        if args['profile']:
            import cProfile 
            import pstats 
            pstatsfile = '{0}_pstats'.format(args['outprefix'])
            logger.info('Performing maximization with cProfile (probably slower).')
            logger.info('Profile stats will be written to {0}'.format(pstatsfile))
            maxresult = []
            def wrapper(maxresult): # wrapper to get return value from cProfile
                maxresult.append(tl.maximizeLikelihood())
            cProfile.runctx('wrapper(maxresult)', globals(), locals(), pstatsfile)
            maxresult = maxresult[0]
            for psort in ['cumulative', 'tottime']:
                fname = '{0}_{1}.txt'.format(pstatsfile, psort)
                logger.info('Writing profile stats sorted by {0} to {1}'.format(
                        psort, fname))
                f = open(fname, 'w')
                s = pstats.Stats(pstatsfile, stream=f)
                s.strip_dirs()
                s.sort_stats(psort)
                s.print_stats()
                f.close()
        else:
            maxresult = tl.maximizeLikelihood()
        logger.info(('Maximization complete after {0} iterations and {1} '
                'function evaluations.').format(maxresult.nit, maxresult.nfev))
        logger.info('Optimized log likelihood is {0:.2f}.'.format(tl.loglik))
        assert scipy.allclose(tl.loglik, -maxresult.fun)
        logger.info('Writing log likelihood to {0}'.format(loglikelihoodfile))
        with open(loglikelihoodfile, 'w') as f:
            f.write('log likelihood = {0:.2f}'.format(tl.loglik))
        params = '\n\t'.join(['{0} = {1:6g}'.format(p, pvalue) for (p, pvalue)
                in sorted(tl.model.paramsReport.items())])
        logger.info('Model parameters after optimization:\n\t{0}'.format(params))
        logger.info('Writing model parameters to {0}'.format(modelparamsfile))
        with open(modelparamsfile, 'w') as f:
            f.write(params.replace('\t', ''))
        logger.info('Writing the optimized tree to {0}\n'.format(treefile))
        Bio.Phylo.write(tl.tree, treefile, 'newick')

        # get number of cpus for multiprocessing
        if args['ncpus'] == -1:
            args['ncpus'] = multiprocessing.cpu_count()
        assert args['ncpus'] >= 1, "{0} CPUs specified".format(args['ncpus'])
        logger.info("Using {0} CPUs for remaining computation.\n".format(
                args['ncpus']))

        # optimize a different omega for each site
        if args['omegabysite']:
            raise RuntimeError("omegabysite not yet implemented")

    except:
        logger.exception('Terminating %s at %s with ERROR' % (prog, time.asctime()))
        raise
    else:
        logger.info('Successful completion of %s' % prog)
    finally:
        logging.shutdown()



if __name__ == '__main__':
    main() # run the script
